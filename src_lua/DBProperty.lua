---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by slanska.
--- DateTime: 2018-01-12 5:37 PM
---

--[[
DBProperty and derived classes.
Used by DBObject/*DBOV to access object property values

Provides access to Boxed(), to be called from custom scripts and functions
Hold list of DBValue items, one item per .ref-value row (or A..P columns in .objects row)
]]

local class = require 'pl.class'
local DBValue = require 'DBValue'
local tablex = require 'pl.tablex'
local Constants = require 'Constants'

-- Constant Null DBValue
local NullDBValue = setmetatable({}, {
    __index = function(idx)

    end,

    __newindex = function(value)
        error('Not assignable null value')
    end,

    __metatable = nil,

-- TODO other methods?
})

-------------------------------------------------------------------------------
--[[
DBProperty
Provides access to simple values (both scalar and vector)
]]
-------------------------------------------------------------------------------
---@class DBProperty
---@field DBOV ReadOnlyDBOV @comment DB Object Version
---@field PropDef PropertyDef
local DBProperty = class()

---@param DBOV ReadOnlyDBOV
---@param propDef PropertyDef
function DBProperty:_init(DBOV, propDef)
    self.DBOV = assert(DBOV)
    self.PropDef = assert(propDef)
end

function DBProperty:Boxed()
    if not self.boxed then
        self.boxed = setmetatable({}, {
            __index = function(idx)
                local vv = self:GetValue(idx)
                if vv then
                    return vv.Boxed()
                end
                return NullDBValue
            end,

            __newindex = function(idx, val)
                return self:SetValue(idx, val)
            end,

            __metatable = nil,

            -- TODO __add, __sub... - for single value
        })
    end

    return self.boxed
end

---@param idx number @comment 1 based index
---@param val any
function DBProperty:SetValue(idx, val)
    error( string.format('Cannot modify readonly version of %s.%s',
                         self.PropDef.ClassDef.Name.text, self.PropDef.Name.text))
end

---@param idx number @comment 1 based
function DBProperty:GetValue(idx)
    self.PropDef.ClassDef.DBContext.AccessControl:ensureCurrentUserAccessForProperty(
            self.PropDef.ID, Constants.OPERATION.READ)

    idx = idx or 1

    if not self.values then
        self.values = {}
    end

    ---@type DBValue
    local v = self.values[idx]

    if not v then
        -- load from db
        local sql = [[select * from [.ref-values]
            where ObjectID = :ObjectID and PropertyID = :PropertyID and PropIndex <= :PropIndex
            order by ObjectID, PropertyID, PropIndex;]]
        for row in self.DBOV.ClassDef.DBContext:loadRows(sql, { ObjectID = self.DBOV.ID,
                                                                PropertyID = self.PropDef.ID, PropIndex = idx }) do
            table.insert(self.values, row.PropIndex, DBValue(row))
        end

        v = assert(self.values[idx])
    end

    return v
end

---@param idx number
---@return DBValue
function DBProperty:cloneValue(idx)
    return tablex.deepcopy( assert(self.values[idx]))
end

-------------------------------------------------------------------------------
--[[
ChangedDBProperty
Used by WritableDBOV (DBObject.curVer)
]]
-------------------------------------------------------------------------------
---@class ChangedDBProperty
---@field DBOV WritableDBOV
---@field PropDef PropertyDef
local ChangedDBProperty = class(DBProperty)

function ChangedDBProperty:_init(DBOV, propDef)
    self:super(DBOV, propDef)
end

---@return DBProperty
function ChangedDBProperty:getOriginalProperty()
    return assert(self.DBOV.DBObject.origVer.props[self.PropDef.Name.text],
                  '' ) -- TODO error message
end

---@param idx number @comment 1 based index
---@param val any
function ChangedDBProperty:SetValue(idx, val)
    if not self.values then
        self.values = {}
    end

    local result = self.values[idx]
    if not result then
        self.PropDef.ClassDef.DBContext.AccessControl:ensureCurrentUserAccessForProperty(
                self.PropDef.ID, self.DBOV.DBObject.state)
        local prop = self:getOriginalProperty()
        result = prop:cloneValue(idx)
        self.values[idx] = result
    end

    if result then
        result.Value = val
    else
        self.PropDef.ClassDef.DBContext.AccessControl:ensureCurrentUserAccessForProperty(
                self.PropDef.ID, idx == 1 and Constants.OPERATION.UPDATE or Constants.OPERATION.CREATE)
        -- is not set - create new one
        result = DBValue { Value = val }
        self.values[idx] = result
    end
end

---@param idx number @comment 1 based index
---@return DBValue
function ChangedDBProperty:GetValue(idx)
    idx = idx or 1

    if not self.values or not self.values[idx] then
        return self:getOriginalProperty():GetValue(idx)
    end

    return self.values[idx]
end

return {
    DBProperty = DBProperty,
    ChangedDBProperty = ChangedDBProperty,
    NullDBValue = NullDBValue
}
