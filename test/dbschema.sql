
PRAGMA page_size = 8192;
PRAGMA journal_mode = WAL;
PRAGMA foreign_keys = 1;
PRAGMA encoding = 'UTF-8';
PRAGMA recursive_triggers = 1;

------------------------------------------------------------------------------------------
-- .generators
------------------------------------------------------------------------------------------
--create table if not exists [.generators] (name TEXT primary key, seq integer) without rowid;
--
--/* -- Sample of generating ID
--  insert or replace into [.generators] (name, seq) select '.objects',
--  coalesce((select seq from [.generators] where name = '.objects') , 0) + 1 ;
--*/

------------------------------------------------------------------------------------------
-- .names
------------------------------------------------------------------------------------------
create table if not exists [.names]
(
    NameID INTEGER  NOT NULL PRIMARY KEY AUTOINCREMENT,
    [Value] TEXT COLLATE BINARY NOT NULL,
    PluralOf integer null
            CONSTRAINT [fkNamesByPluralOf]
            REFERENCES [.names] ([NameID]) ON DELETE SET NULL ON UPDATE RESTRICT,
    AliasOf integer null
            CONSTRAINT [fkNamesByAliasOf]
            REFERENCES [.names] ([NameID]) ON DELETE SET NULL ON UPDATE RESTRICT,

    Data JSON1 null
);

create unique index if not exists [namesByValue] on [.names]([Value]);
create  index if not exists [namesByAliasOf] on [.names]([AliasOf]) where AliasOf is not null;
create  index if not exists [namesByPluralOf] on [.names]([PluralOf]) where PluralOf is not null;

------------------------------------------------------------------------------------------
-- .access_rules
------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS [.access_rules] (
  [UserRoleID] GUID NOT NULL,
  [ItemType]   CHAR NOT NULL,
  [Access]     CHAR NOT NULL,
  [ItemID]     INT  NOT NULL,
  CONSTRAINT [sqlite_autoindex_AccessRules_1] PRIMARY KEY ([UserRoleID], [ItemType], [ItemID])
) WITHOUT ROWID;

CREATE INDEX IF NOT EXISTS [idxAccessRulesByItemID] ON [.access_rules] ([ItemID]);

------------------------------------------------------------------------------------------
-- .change_log
------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS [.change_log] (
  [ID]        INTEGER  NOT NULL PRIMARY KEY AUTOINCREMENT,
  [TimeStamp] DATETIME NOT NULL             DEFAULT (julianday('now')),
  [OldKey] TEXT NULL,
  [OldValue]  JSON1,

  -- Format for key and oldkey
  -- @collectionID-schemaID.objectID#propertyID[propertyIndex]
  -- Example: @23-134.188374#345[11]
  [KEY] TEXT NULL,
  [Value]     JSON1,

  -- TODO Implement function
  [ChangedBy] GUID              -- DEFAULT (GetCurrentUserID())
);

------------------------------------------------------------------------------------------
-- .schemas
------------------------------------------------------------------------------------------
create table if not exists [.schemas]
(
[SchemaID] INTEGER  NOT NULL PRIMARY KEY AUTOINCREMENT,
[NameID] INTEGER NOT NULL CONSTRAINT [fkSchemaToName]
    REFERENCES [.names] ([NameID])
    ON DELETE RESTRICT ON UPDATE RESTRICT,
[Variation] INTEGER NULL
[Data] JSON1 NOT NULL,

-- 40 char hash code of Data (as generated by object-hash node.js module)
[Hash] TEXT(40) not null COLLATE BINARY
);

create unique index if not exists [idxSchemasByName] on [.schemas] (NameID);

create index if not exists [idxSchemaByHash] on [.schema] ([Hash], [CollectionID]);

-- Trigger
-- on update of Data - create copy of old schema if Data has changed
CREATE TRIGGER IF NOT EXISTS [trigSchemasAfterUpdate]
AFTER UPDATE
ON [.schemas]
FOR EACH ROW
WHEN old.[Data] <> new.[Data] and old.[PreviousSchemaID] is null
BEGIN
    -- Validate Properties for Name IDs
    select raise_error('Failed constraint: every property ID should match existing name ID')
        from (select key from json_each(new.Data, '$.properties') where atom is null
        and not exists (select NameID from [.names] where NameID = [Key]));

      INSERT INTO [.change_log] ([KEY], [Value], [OldKey], [OldValue]) VALUES (
        printf('-%s', new.SchemaID),
        json_set('{}',
        "$.SchemaID", new.SchemaID,
        "$.NameID", new.NameID,
        "$.Variation", new.Variation,
        "$.Data", new.Data
        ),

        printf('-%s', old.SchemaID),
        json_set('{}',
                "$.SchemaID", old.SchemaID,
                "$.NameID", old.NameID,
                "$.Variation", old.Variation,
                "$.Data", old.Data
                )
      );
END;

CREATE TRIGGER IF NOT EXISTS [trigSchemasAfterInsert]
AFTER INSERT
ON [.schemas]
FOR EACH ROW
BEGIN
    update [.schemas] set Variation = new.SchemaID where SchemaID = new.SchemaID and Variation = -1;

    -- Validate Properties for name IDs
    select raise_error('Failed constraint: every property ID should match existing name ID')
        from (select key from json_each(new.Data, '$.properties') where atom is null
        and not exists (select NameID from [.names] where NameID = [Key]));

        -- Update change log
      INSERT INTO [.change_log] ([KEY], [Value]) VALUES (
        printf('-%s', new.SchemaID),
        json_set('{}',
        "$.SchemaID", new.SchemaID,
        "$.NameID", new.NameID,
        "$.Variation", new.Variation,
        "$.Data", new.Data
        )
      );
END;

CREATE TRIGGER IF NOT EXISTS [trigSchemasAfterDelete]
AFTER DELETE
ON [.schemas]
FOR EACH ROW
BEGIN
      INSERT INTO [.change_log] ([OldKey], [OldValue]) VALUES (
        printf('-%s', old.SchemaID),
        json_set('{}',
        "$.SchemaID", old.SchemaID,
        "$.NameID", old.NameID,
        "$.Variation", old.Variation,
        "$.Data", old.Data
        )
      );
END;

------------------------------------------------------------------------------------------
-- .collections
------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS [.collections] (
  [CollectionID]           INTEGER  NOT NULL PRIMARY KEY AUTOINCREMENT,
  [NameID]         TEXT(64) NOT NULL CONSTRAINT [fkCollectionsNameID]
                                         REFERENCES [.names] ([NameID]) ON DELETE RESTRICT ON UPDATE RESTRICT,
  [ViewOutdated] BOOL NOT NULL DEFAULT 0,

  /*
  Name ID of base schema used for the collection. The most version of base schema (where Variation is null) is used
  for new collection items
  */
  [BaseSchemaNameID] INTEGER NOT NULL,


    -- System class is used internally by the system and cannot be changed or deleted by end-user

  [SystemCollection] BOOL     NOT NULL             DEFAULT 0,

-- Optional mappings for JSON property shortcuts and/or indexing
-- Values are property IDs
  [A] INTEGER NULL,
  [B] INTEGER NULL,
  [C] INTEGER NULL,
  [D] INTEGER NULL,
  [E] INTEGER NULL,
  [F] INTEGER NULL,
  [G] INTEGER NULL,
  [H] INTEGER NULL,
  [I] INTEGER NULL,
  [J] INTEGER NULL,

  -- Control bitmask for objects belonging to this class
  [ctloMask] INTEGER NOT NULL DEFAULT 0,

  Capacity INTEGER NULL,

  SchemaRules JSON1 NULL,
  AccessRules JSON1 NULL
);

CREATE UNIQUE INDEX IF NOT EXISTS [idxCollections_byNameID] ON [.collections] ([NameID]);

CREATE TRIGGER IF NOT EXISTS [trigCollectionsAfterInsert]
AFTER INSERT
ON [.collections]
FOR EACH ROW
BEGIN
  INSERT INTO [.change_log] ([KEY], [Value]) VALUES (
    printf('@%s', new.CollectionID),
    json_set('{}',
             "$.NameID" , new.NameID,
             "$.SystemCollection" , new.SystemCollection,
             "$.ViewOutdated" , new.ViewOutdated,
             "$.BaseSchemaNameID", new.BaseSchemaNameID,
             "$.ctloMask" , new.ctloMask,

            CASE WHEN new.Capacity IS NULL
            THEN NULL
            ELSE "$.Capacity" END, new.Capacity,

            CASE WHEN new.SchemaRules IS NULL
            THEN NULL
            ELSE "$.SchemaRules" END, new.SchemaRules,

            CASE WHEN new.AccessRules IS NULL
              THEN NULL
            ELSE "$.AccessRules" END, new.AccessRules,

             CASE WHEN new.A IS NULL
               THEN NULL
             ELSE "$.A" END, new.A,

             CASE WHEN new.B IS NULL
               THEN NULL
             ELSE "$.B" END, new.B,

            CASE WHEN new.C IS NULL
            THEN NULL
            ELSE "$.C" END, new.C,

            CASE WHEN new.D IS NULL
            THEN NULL
            ELSE "$.D" END, new.D,

            CASE WHEN new.E IS NULL
            THEN NULL
            ELSE "$.E" END, new.E,

            CASE WHEN new.F IS NULL
            THEN NULL
            ELSE "$.F" END, new.F,

            CASE WHEN new.G IS NULL
            THEN NULL
            ELSE "$.G" END, new.G,

            CASE WHEN new.H IS NULL
            THEN NULL
            ELSE "$.H" END, new.H,

            CASE WHEN new.I IS NULL
            THEN NULL
            ELSE "$.I" END, new.I,

            CASE WHEN new.J IS NULL
            THEN NULL
            ELSE "$.J" END, new.J
    )
  );

  -- Update objects with shortcuts if needed
  -- TODO Use internal view to get access to properties
  update [.objects] set
        [ctlo] = new.[ctloMask],
        [A] = (select json_extract([Data], '$.properties.' || new.A || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [B] = (select json_extract([Data], '$.properties.' || new.B || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [C] = (select json_extract([Data], '$.properties.' || new.C || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [D] = (select json_extract([Data], '$.properties.' || new.D || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [E] = (select json_extract([Data], '$.properties.' || new.E || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [F] = (select json_extract([Data], '$.properties.' || new.F || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [G] = (select json_extract([Data], '$.properties.' || new.G || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [H] = (select json_extract([Data], '$.properties.' || new.H || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [I] = (select json_extract([Data], '$.properties.' || new.I || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [J] = (select json_extract([Data], '$.properties.' || new.J || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID])

        where [CollectionID] = new.CollectionID;
END;

CREATE TRIGGER IF NOT EXISTS [trigCollectionsAfterUpdate]
AFTER UPDATE
ON [.collections]
FOR EACH ROW
BEGIN
  INSERT INTO [.change_log] ([OldKey], [OldValue], [KEY], [Value])
    SELECT
      [OldKey],
      [OldValue],
      [KEY],
      [Value]
    FROM (
      SELECT
        '@' || CAST(nullif(old.CollectionID, new.CollectionID) AS TEXT)                             AS [OldKey],

        json_set('{}',
             "$.NameID" , old.NameID,
             "$.SystemCollection" , old.SystemCollection,
             "$.ViewOutdated" , old.ViewOutdated,
             "$.BaseSchemaNameID", old.BaseSchemaNameID,
             "$.ctloMask" , old.ctloMask,

            CASE WHEN old.Capacity IS NULL
            THEN NULL
            ELSE "$.Capacity" END, old.Capacity,

            CASE WHEN old.SchemaRules IS NULL
            THEN NULL
            ELSE "$.SchemaRules" END, old.SchemaRules,

            CASE WHEN old.AccessRules IS NULL
              THEN NULL
            ELSE "$.AccessRules" END, old.AccessRules,

             CASE WHEN old.A IS NULL
               THEN NULL
             ELSE "$.A" END, old.A,

             CASE WHEN old.B IS NULL
               THEN NULL
             ELSE "$.B" END, old.B,

            CASE WHEN old.C IS NULL
            THEN NULL
            ELSE "$.C" END, old.C,

            CASE WHEN old.D IS NULL
            THEN NULL
            ELSE "$.D" END, old.D,

            CASE WHEN old.E IS NULL
            THEN NULL
            ELSE "$.E" END, old.E,

            CASE WHEN old.F IS NULL
            THEN NULL
            ELSE "$.F" END, old.F,

            CASE WHEN old.G IS NULL
            THEN NULL
            ELSE "$.G" END, old.G,

            CASE WHEN old.H IS NULL
            THEN NULL
            ELSE "$.H" END, old.H,

            CASE WHEN old.I IS NULL
            THEN NULL
            ELSE "$.I" END, old.I,

            CASE WHEN old.J IS NULL
            THEN NULL
            ELSE "$.J" END, old.J
        ) AS [OldValue],

        '@' || CAST(new.CollectionID AS TEXT)                                                  AS [KEY],
                json_set('{}',
             "$.NameID" , new.NameID,
             "$.SystemCollection" , new.SystemCollection,
             "$.ViewOutdated" , new.ViewOutdated,
             "$.BaseSchemaNameID", new.BaseSchemaNameID,
             "$.ctloMask" , new.ctloMask,

            CASE WHEN new.Capacity IS NULL
            THEN NULL
            ELSE "$.Capacity" END, new.Capacity,

            CASE WHEN new.SchemaRules IS NULL
            THEN NULL
            ELSE "$.SchemaRules" END, new.SchemaRules,

            CASE WHEN new.AccessRules IS NULL
              THEN NULL
            ELSE "$.AccessRules" END, new.AccessRules,

             CASE WHEN new.A IS NULL
               THEN NULL
             ELSE "$.A" END, new.A,

             CASE WHEN new.B IS NULL
               THEN NULL
             ELSE "$.B" END, new.B,

            CASE WHEN new.C IS NULL
            THEN NULL
            ELSE "$.C" END, new.C,

            CASE WHEN new.D IS NULL
            THEN NULL
            ELSE "$.D" END, new.D,

            CASE WHEN new.E IS NULL
            THEN NULL
            ELSE "$.E" END, new.E,

            CASE WHEN new.F IS NULL
            THEN NULL
            ELSE "$.F" END, new.F,

            CASE WHEN new.G IS NULL
            THEN NULL
            ELSE "$.G" END, new.G,

            CASE WHEN new.H IS NULL
            THEN NULL
            ELSE "$.H" END, new.H,

            CASE WHEN new.I IS NULL
            THEN NULL
            ELSE "$.I" END, new.I,

            CASE WHEN new.J IS NULL
            THEN NULL
            ELSE "$.J" END, new.J
        )
        AS [Value]
    )
    WHERE [OldValue] <> [Value] OR (nullif([OldKey], [KEY])) IS NOT NULL;
END;

CREATE TRIGGER IF NOT EXISTS [trigCollectionsAfterUpdateOfctloMaskOrColumns]
AFTER UPDATE OF [ctloMask], [A], [B], [C], [D], [E], [F], [G], [H], [I], [J]
ON [.collections]
FOR EACH ROW
BEGIN
  -- Update objects with shortcuts if needed
    -- TODO Use internal view to get access to properties
  update [.objects] set
        [ctlo] = new.[ctloMask],
        [A] = (select json_extract([Data], '$.properties.' || new.A || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [B] = (select json_extract([Data], '$.properties.' || new.B || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [C] = (select json_extract([Data], '$.properties.' || new.C || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [D] = (select json_extract([Data], '$.properties.' || new.D || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [E] = (select json_extract([Data], '$.properties.' || new.E || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [F] = (select json_extract([Data], '$.properties.' || new.F || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [G] = (select json_extract([Data], '$.properties.' || new.G || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [H] = (select json_extract([Data], '$.properties.' || new.H || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [I] = (select json_extract([Data], '$.properties.' || new.I || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID]),
        [J] = (select json_extract([Data], '$.properties.' || new.J || '.jsonPath')
            from [.schemas] s where s.[SchemaID] = [SchemaID])

        where [CollectionID] = new.CollectionID;
END;

CREATE TRIGGER IF NOT EXISTS [trigCollectionsAfterDelete]
AFTER DELETE
ON [.collections]
FOR EACH ROW
BEGIN
  INSERT INTO [.change_log] ([OldKey], [OldValue]) VALUES (
    printf('@%s', old.CollectionID),

    json_set('{}',
              "$.NameID" , old.NameID,
              "$.SystemCollection" , old.SystemCollection,
              "$.ViewOutdated" , old.ViewOutdated,
              "$.BaseSchemaNameID", old.BaseSchemaNameID,
              "$.ctloMask" , old.ctloMask,

            CASE WHEN old.Capacity IS NULL
            THEN NULL
            ELSE "$.Capacity" END, old.Capacity,

            CASE WHEN old.SchemaRules IS NULL
            THEN NULL
            ELSE "$.SchemaRules" END, old.SchemaRules,

            CASE WHEN old.AccessRules IS NULL
              THEN NULL
            ELSE "$.AccessRules" END, old.AccessRules,

              CASE WHEN old.A IS NULL
                THEN NULL
              ELSE "$.A" END, old.A,

              CASE WHEN old.B IS NULL
                THEN NULL
              ELSE "$.B" END, old.B,

             CASE WHEN old.C IS NULL
             THEN NULL
             ELSE "$.C" END, old.C,

             CASE WHEN old.D IS NULL
             THEN NULL
             ELSE "$.D" END, old.D,

             CASE WHEN old.E IS NULL
             THEN NULL
             ELSE "$.E" END, old.E,

             CASE WHEN old.F IS NULL
             THEN NULL
             ELSE "$.F" END, old.F,

             CASE WHEN old.G IS NULL
             THEN NULL
             ELSE "$.G" END, old.G,

             CASE WHEN old.H IS NULL
             THEN NULL
             ELSE "$.H" END, old.H,

             CASE WHEN old.I IS NULL
             THEN NULL
             ELSE "$.I" END, old.I,

             CASE WHEN old.J IS NULL
             THEN NULL
             ELSE "$.J" END, old.J
    )
  );
END;


------------------------------------------------------------------------------------------
-- .full_text_data
------------------------------------------------------------------------------------------
CREATE VIRTUAL TABLE IF NOT EXISTS [.full_text_data] USING fts4 (

  [PropertyID],
  [CollectionID],
  [ObjectID],
  [PropertyIndex],
  [Value],

  tokenize=unicode61
);

------------------------------------------------------------------------------------------
-- [.objects]
------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS [.objects] (
  [ObjectID] INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
  [CollectionID]  INTEGER NOT NULL CONSTRAINT [fkObjectsCollectionIDToClasses]
    REFERENCES [.collections] ([CollectionID]) ON DELETE CASCADE ON UPDATE CASCADE,
[SchemaID] INTEGER not null
    CONSTRAINT [fkObjectsSchemaIDToClasses]
    REFERENCES [.schemas] ([SchemaID]) ON DELETE RESTRICT ON UPDATE RESTRICT,

  /*
  This is bit mask which regulates index storage.
  Bit 0: this object is a WEAK object and must be auto deleted after last reference to this object gets deleted.
  Bits 1-16: columns A-P should be indexed for fast lookup. These bits are checked by partial indexes
  Bits 17-32: columns A-P should be indexed for full text search
  Bits 33-48: columns A-P should be treated as range values and indexed for range (spatial search) search
  Bit 49: DON'T track changes
  Bit 50: Schema is not validated. Normally, this bit is set when object was referenced in other object
  but it was not defined in the schema

  */
  [ctlo] INTEGER,
  [A],
  [B],
  [C],
  [D],
  [E],
  [F],
  [G],
  [H],
  [I],
  [J],
 [Data] JSON1 NULL
);

CREATE INDEX IF NOT EXISTS [idxObjectsByCollectionID] ON [.objects] ([CollectionID]);

CREATE INDEX IF NOT EXISTS [idxObjectsByA] ON [.objects] ([CollectionID], [A]) WHERE (ctlo AND (1 << 1)) <> 0 AND [A] IS NOT NULL;

CREATE INDEX IF NOT EXISTS [idxObjectsByB] ON [.objects] ([CollectionID], [B]) WHERE (ctlo AND (1 << 2)) <> 0 AND [B] IS NOT NULL;

CREATE INDEX IF NOT EXISTS [idxObjectsByC] ON [.objects] ([CollectionID], [C]) WHERE (ctlo AND (1 << 3)) <> 0 AND [C] IS NOT NULL;

CREATE INDEX IF NOT EXISTS [idxObjectsByD] ON [.objects] ([CollectionID], [D]) WHERE (ctlo AND (1 << 4)) <> 0 AND [D] IS NOT NULL;

CREATE INDEX IF NOT EXISTS [idxObjectsByE] ON [.objects] ([CollectionID], [E]) WHERE (ctlo AND (1 << 5)) <> 0 AND [E] IS NOT NULL;

CREATE INDEX IF NOT EXISTS [idxObjectsByF] ON [.objects] ([CollectionID], [F]) WHERE (ctlo AND (1 << 6)) <> 0 AND [F] IS NOT NULL;

CREATE INDEX IF NOT EXISTS [idxObjectsByG] ON [.objects] ([CollectionID], [G]) WHERE (ctlo AND (1 << 7)) <> 0 AND [G] IS NOT NULL;

CREATE INDEX IF NOT EXISTS [idxObjectsByH] ON [.objects] ([CollectionID], [H]) WHERE (ctlo AND (1 << 8)) <> 0 AND [H] IS NOT NULL;

CREATE INDEX IF NOT EXISTS [idxObjectsByI] ON [.objects] ([CollectionID], [I]) WHERE (ctlo AND (1 << 9)) <> 0 AND [I] IS NOT NULL;

CREATE INDEX IF NOT EXISTS [idxObjectsByJ] ON [.objects] ([CollectionID], [J]) WHERE (ctlo AND (1 << 10)) <> 0 AND [J] IS NOT NULL;

-- Triggers
CREATE TRIGGER IF NOT EXISTS [trigObjectsAfterInsert]
AFTER INSERT
ON [.objects]
FOR EACH ROW
BEGIN
  -- TODO force ctlo. Will it work?
  UPDATE [.objects]
  SET ctlo = coalesce(new.ctlo, (SELECT [ctlo]
                                 FROM [.collections]
                                 WHERE [CollectionID] = new.[CollectionID]))
  WHERE ObjectID = new.[ObjectID];

  INSERT INTO [.change_log] ([KEY], [Value])
    SELECT
      printf('@%s.%s', new.[CollectionID], new.[ObjectID]),
      json_set('{}',
      '$.SchemaID', new.SchemaID,
      '$.Data', new.Data,
     CASE WHEN new.HostID IS NULL THEN NULL ELSE '$.HostID' END, new.HostID,
        CASE WHEN new.A IS NULL THEN NULL ELSE '$.A' END, new.A,
        CASE WHEN new.B IS NULL THEN NULL ELSE '$.B' END, new.B,
        CASE WHEN new.C IS NULL THEN NULL ELSE '$.C' END, new.C,
        CASE WHEN new.D IS NULL THEN NULL ELSE '$.D' END, new.D,
        CASE WHEN new.E IS NULL THEN NULL ELSE '$.E' END, new.E,
        CASE WHEN new.F IS NULL THEN NULL ELSE '$.F' END, new.F,
        CASE WHEN new.G IS NULL THEN NULL ELSE '$.G' END, new.G,
        CASE WHEN new.H IS NULL THEN NULL ELSE '$.H' END, new.H,
        CASE WHEN new.I IS NULL THEN NULL ELSE '$.I' END, new.I,
        CASE WHEN new.J IS NULL THEN NULL ELSE '$.J' END, new.J,
        CASE WHEN new.ctlo IS NULL THEN NULL ELSE '$.ctlo' END, new.ctlo

   )
    WHERE new.[ctlo] IS NULL OR new.[ctlo] & (1 << 49);

  -- Full text and range data using INSTEAD OF triggers of dummy view
  INSERT INTO [.vw_object_column_data] ([CollectionID], [ObjectID], [ctlo], [ColumnAssigned], [Value]) VALUES
    (
      new.[CollectionID], new.[ObjectID], new.[ctlo], 'A', new.[A]
    );
  INSERT INTO [.vw_object_column_data] ([CollectionID], [ObjectID], [ctlo], [ColumnAssigned], [Value]) VALUES
    (
      new.[CollectionID], new.[ObjectID], new.[ctlo], 'B', new.[B]
    );

  INSERT INTO [.vw_object_column_data] ([CollectionID], [ObjectID], [ctlo], [ColumnAssigned], [Value]) VALUES
    (
      new.[CollectionID], new.[ObjectID], new.[ctlo], 'C', new.[C]
    );
  INSERT INTO [.vw_object_column_data] ([CollectionID], [ObjectID], [ctlo], [ColumnAssigned], [Value]) VALUES
    (
      new.[CollectionID], new.[ObjectID], new.[ctlo], 'D', new.[D]
    );
  INSERT INTO [.vw_object_column_data] ([CollectionID], [ObjectID], [ctlo], [ColumnAssigned], [Value]) VALUES
    (
      new.[CollectionID], new.[ObjectID], new.[ctlo], 'E', new.[E]
    );
  INSERT INTO [.vw_object_column_data] ([CollectionID], [ObjectID], [ctlo], [ColumnAssigned], [Value]) VALUES
    (
      new.[CollectionID], new.[ObjectID], new.[ctlo], 'F', new.[F]
    );
  INSERT INTO [.vw_object_column_data] ([CollectionID], [ObjectID], [ctlo], [ColumnAssigned], [Value]) VALUES
    (
      new.[CollectionID], new.[ObjectID], new.[ctlo], 'G', new.[G]
    );
  INSERT INTO [.vw_object_column_data] ([CollectionID], [ObjectID], [ctlo], [ColumnAssigned], [Value]) VALUES
    (
      new.[CollectionID], new.[ObjectID], new.[ctlo], 'H', new.[H]
    );
  INSERT INTO [.vw_object_column_data] ([CollectionID], [ObjectID], [ctlo], [ColumnAssigned], [Value]) VALUES
    (
      new.[CollectionID], new.[ObjectID], new.[ctlo], 'I', new.[I]
    );
  INSERT INTO [.vw_object_column_data] ([CollectionID], [ObjectID], [ctlo], [ColumnAssigned], [Value]) VALUES
    (
      new.[CollectionID], new.[ObjectID], new.[ctlo], 'J', new.[J]
    );

END;

CREATE TRIGGER IF NOT EXISTS [trigObjectsAfterUpdate]
AFTER UPDATE
ON [.objects]
FOR EACH ROW
BEGIN
  INSERT INTO [.change_log] ([OldKey], [OldValue], [KEY], [Value])
    SELECT
      [OldKey],
      [OldValue],
      [KEY],
      [Value]
    FROM
      (SELECT
         '@' || CAST(nullif(old.CollectionID, new.CollectionID) AS TEXT) || '.' ||
         CAST(nullif(old.ObjectID, new.[ObjectID]) AS TEXT) AS [OldKey],

        json_set('{}',
        '$.SchemaID', new.SchemaID,
              '$.Data', new.Data,
             CASE WHEN new.HostID IS NULL THEN NULL ELSE '$.HostID' END, new.HostID,
          CASE WHEN nullif(new.A, old.A) IS NULL THEN NULL ELSE '$.A' END, new.A,
            CASE WHEN nullif(new.B, old.B) IS NULL THEN NULL ELSE '$.B' END, new.B,
          CASE WHEN nullif(new.C, old.C) IS NULL THEN NULL ELSE '$.C' END, new.C,
            CASE WHEN nullif(new.D, old.D) IS NULL THEN NULL ELSE '$.D' END, new.D,
          CASE WHEN nullif(new.E, old.E) IS NULL THEN NULL ELSE '$.E' END, new.E,
            CASE WHEN nullif(new.F, old.F) IS NULL THEN NULL ELSE '$.F' END, new.F,
          CASE WHEN nullif(new.G, old.G) IS NULL THEN NULL ELSE '$.G' END, new.G,
            CASE WHEN nullif(new.H, old.H) IS NULL THEN NULL ELSE '$.H' END, new.H,
          CASE WHEN nullif(new.I, old.I) IS NULL THEN NULL ELSE '$.I' END, new.I,
            CASE WHEN nullif(new.J, old.J) IS NULL THEN NULL ELSE '$.J' END, new.J,

          CASE WHEN nullif(new.ctlo, old.ctlo) IS NULL THEN NULL ELSE '$.ctlo' END, new.ctlo
         )                                                  AS [OldValue],
         printf('@%s.%s', new.[CollectionID], new.[ObjectID])    AS [KEY],
         json_set('{}',
         CASE WHEN nullif(new.SchemaID, old.SchemaID) IS NULL THEN NULL ELSE '$.SchemaID' END, old.SchemaID,
               CASE WHEN nullif(new.Data, old.Data) IS NULL THEN NULL ELSE '$.Data' END, old.Data,
              CASE WHEN nullif(new.HostID, old.HostID) IS NULL THEN NULL ELSE '$.HostID' END, old.HostID,
          CASE WHEN nullif(new.A, old.A) IS NULL THEN NULL ELSE '$.A' END, old.A,
            CASE WHEN nullif(new.B, old.B) IS NULL THEN NULL ELSE '$.B' END, old.B,
          CASE WHEN nullif(new.C, old.C) IS NULL THEN NULL ELSE '$.C' END, old.C,
            CASE WHEN nullif(new.D, old.D) IS NULL THEN NULL ELSE '$.D' END, old.D,
          CASE WHEN nullif(new.E, old.E) IS NULL THEN NULL ELSE '$.E' END, old.E,
            CASE WHEN nullif(new.F, old.F) IS NULL THEN NULL ELSE '$.F' END, old.F,
          CASE WHEN nullif(new.G, old.G) IS NULL THEN NULL ELSE '$.G' END, old.G,
            CASE WHEN nullif(new.H, old.H) IS NULL THEN NULL ELSE '$.H' END, old.H,
          CASE WHEN nullif(new.I, old.I) IS NULL THEN NULL ELSE '$.I' END, old.I,
            CASE WHEN nullif(new.J, old.J) IS NULL THEN NULL ELSE '$.J' END, old.J,

          CASE WHEN nullif(new.ctlo, old.ctlo) IS NULL THEN NULL ELSE '$.ctlo' END, old.ctlo
         )
                                                         AS [Value]
      )
    WHERE (new.[ctlo] IS NULL OR new.[ctlo] & (1 << 49))
          AND ([OldValue] <> [Value] OR (nullif([OldKey], [KEY])) IS NOT NULL);

  -- Update columns' full text and range data using dummy view with INSTEAD OF triggers
  UPDATE [.vw_object_column_data]
  SET [oldCollectionID] = old.[CollectionID], [oldObjectID] = old.[ObjectID], [ColumnAssigned] = 'A', [oldValue] = old.[A],
    [CollectionID]      = new.[CollectionID], [ObjectID] = new.[ObjectID], [ColumnAssigned] = 'A', [Value] = new.[A],
    [oldctlo]      = old.[ctlo], [ctlo] = new.[ctlo];
  UPDATE [.vw_object_column_data]
  SET [oldCollectionID] = old.[CollectionID], [oldObjectID] = old.[ObjectID], [ColumnAssigned] = 'B', [oldValue] = old.[B],
    [CollectionID]      = new.[CollectionID], [ObjectID] = new.[ObjectID], [ColumnAssigned] = 'B', [Value] = new.[B],
    [oldctlo]      = old.[ctlo], [ctlo] = new.[ctlo];
  UPDATE [.vw_object_column_data]
  SET [oldCollectionID] = old.[CollectionID], [oldObjectID] = old.[ObjectID], [ColumnAssigned] = 'C', [oldValue] = old.[C],
    [CollectionID]      = new.[CollectionID], [ObjectID] = new.[ObjectID], [ColumnAssigned] = 'C', [Value] = new.[C],
    [oldctlo]      = old.[ctlo], [ctlo] = new.[ctlo];
  UPDATE [.vw_object_column_data]
  SET [oldCollectionID] = old.[CollectionID], [oldObjectID] = old.[ObjectID], [ColumnAssigned] = 'D', [oldValue] = old.[D],
    [CollectionID]      = new.[CollectionID], [ObjectID] = new.[ObjectID], [ColumnAssigned] = 'D', [Value] = new.[D],
    [oldctlo]      = old.[ctlo], [ctlo] = new.[ctlo];
  UPDATE [.vw_object_column_data]
  SET [oldCollectionID] = old.[CollectionID], [oldObjectID] = old.[ObjectID], [ColumnAssigned] = 'E', [oldValue] = old.[E],
    [CollectionID]      = new.[CollectionID], [ObjectID] = new.[ObjectID], [ColumnAssigned] = 'E', [Value] = new.[E],
    [oldctlo]      = old.[ctlo], [ctlo] = new.[ctlo];
  UPDATE [.vw_object_column_data]
  SET [oldCollectionID] = old.[CollectionID], [oldObjectID] = old.[ObjectID], [ColumnAssigned] = 'F', [oldValue] = old.[F],
    [CollectionID]      = new.[CollectionID], [ObjectID] = new.[ObjectID], [ColumnAssigned] = 'F', [Value] = new.[F],
    [oldctlo]      = old.[ctlo], [ctlo] = new.[ctlo];
  UPDATE [.vw_object_column_data]
  SET [oldCollectionID] = old.[CollectionID], [oldObjectID] = old.[ObjectID], [ColumnAssigned] = 'G', [oldValue] = old.[G],
    [CollectionID]      = new.[CollectionID], [ObjectID] = new.[ObjectID], [ColumnAssigned] = 'G', [Value] = new.[G],
    [oldctlo]      = old.[ctlo], [ctlo] = new.[ctlo];
  UPDATE [.vw_object_column_data]
  SET [oldCollectionID] = old.[CollectionID], [oldObjectID] = old.[ObjectID], [ColumnAssigned] = 'H', [oldValue] = old.[H],
    [CollectionID]      = new.[CollectionID], [ObjectID] = new.[ObjectID], [ColumnAssigned] = 'H', [Value] = new.[H],
    [oldctlo]      = old.[ctlo], [ctlo] = new.[ctlo];
  UPDATE [.vw_object_column_data]
  SET [oldCollectionID] = old.[CollectionID], [oldObjectID] = old.[ObjectID], [ColumnAssigned] = 'I', [oldValue] = old.[I],
    [CollectionID]      = new.[CollectionID], [ObjectID] = new.[ObjectID], [ColumnAssigned] = 'I', [Value] = new.[I],
    [oldctlo]      = old.[ctlo], [ctlo] = new.[ctlo];
  UPDATE [.vw_object_column_data]
  SET [oldCollectionID] = old.[CollectionID], [oldObjectID] = old.[ObjectID], [ColumnAssigned] = 'J', [oldValue] = old.[J],
    [CollectionID]      = new.[CollectionID], [ObjectID] = new.[ObjectID], [ColumnAssigned] = 'J', [Value] = new.[J],
    [oldctlo]      = old.[ctlo], [ctlo] = new.[ctlo];

END;

CREATE TRIGGER IF NOT EXISTS [trigObjectsAfterUpdateOfCollectionID_ObjectID]
AFTER UPDATE OF [CollectionID], [ObjectID]
ON [.objects]
FOR EACH ROW
BEGIN
  -- Force updating indexes for direct columns
  UPDATE [.objects]
  SET ctlo = new.ctlo
  WHERE ObjectID = new.[ObjectID];

  -- Cascade update values
  UPDATE [.ref-values]
  SET ObjectID = new.[ObjectID], CollectionID = new.CollectionID
  WHERE ObjectID = old.ObjectID
        AND (new.[ObjectID] <> old.ObjectID OR new.CollectionID <> old.CollectionID);

  -- and shifted values
  UPDATE [.ref-values]
  SET ObjectID = (1 << 62) | new.[ObjectID], CollectionID = new.CollectionID
  WHERE ObjectID = (1 << 62) | old.ObjectID
        AND (new.[ObjectID] <> old.ObjectID OR new.CollectionID <> old.CollectionID);

  -- Update back references
  UPDATE [.ref-values]
  SET [Value] = new.[ObjectID]
  WHERE [Value] = old.ObjectID AND ctlv IN (0, 10) AND new.[ObjectID] <> old.ObjectID;
END;


CREATE TRIGGER IF NOT EXISTS [trigObjectsAfterDelete]
AFTER DELETE
ON [.objects]
FOR EACH ROW
BEGIN
  INSERT INTO [.change_log] ([OldKey], [OldValue])
    SELECT
      printf('@%s.%s', old.[CollectionID], old.[ObjectID]),
      json_set('{}',
       CASE WHEN old.SchemaID IS NULL THEN NULL ELSE '$.SchemaID' END, old.SchemaID,
                     CASE WHEN old.Data IS NULL THEN NULL ELSE '$.Data' END, old.Data,
                    CASE WHEN old.HostID IS NULL THEN NULL ELSE '$.HostID' END, old.HostID,
        CASE WHEN old.A IS NULL THEN NULL ELSE '$.A' END, old.A,
          CASE WHEN old.B IS NULL THEN NULL ELSE '$.B' END, old.B,
        CASE WHEN old.C IS NULL THEN NULL ELSE '$.C' END, old.C,
          CASE WHEN old.D IS NULL THEN NULL ELSE '$.D' END, old.D,
        CASE WHEN old.E IS NULL THEN NULL ELSE '$.E' END, old.E,
          CASE WHEN old.F IS NULL THEN NULL ELSE '$.F' END, old.F,
        CASE WHEN old.G IS NULL THEN NULL ELSE '$.G' END, old.G,
          CASE WHEN old.H IS NULL THEN NULL ELSE '$.H' END, old.H,
        CASE WHEN old.I IS NULL THEN NULL ELSE '$.I' END, old.I,
          CASE WHEN old.J IS NULL THEN NULL ELSE '$.J' END, old.J,

        CASE WHEN old.ctlo IS NULL THEN NULL ELSE '$.ctlo' END, old.ctlo
      )

    WHERE old.[ctlo] IS NULL OR old.[ctlo] & (1 << 49);

  -- Delete all objects that are referenced from this object and marked for cascade delete (ctlv = 10)
  DELETE FROM [.objects]
  WHERE ObjectID IN (SELECT Value
                     FROM [.ref-values]
                     WHERE ObjectID IN (old.ObjectID, (1 << 62) | old.ObjectID) AND ctlv = 10);

  -- Delete all reversed references
  DELETE FROM [.ref-values]
  WHERE [Value] = ObjectID AND [ctlv] IN (0, 10);

  -- Delete all Values
  DELETE FROM [.ref-values]
  WHERE ObjectID IN (old.ObjectID, (1 << 62) | old.ObjectID);

  -- Delete full text and range data using dummy view with INSTEAD OF triggers
  DELETE FROM [.vw_object_column_data]
  WHERE [oldCollectionID] = old.[CollectionID] AND [oldObjectID] = old.[ObjectID] AND [oldctlo] = old.[ctlo]
        AND [ColumnAssigned] = 'A';
  DELETE FROM [.vw_object_column_data]
  WHERE [oldCollectionID] = old.[CollectionID] AND [oldObjectID] = old.[ObjectID] AND [oldctlo] = old.[ctlo]
        AND [ColumnAssigned] = 'B';
  DELETE FROM [.vw_object_column_data]
  WHERE [oldCollectionID] = old.[CollectionID] AND [oldObjectID] = old.[ObjectID] AND [oldctlo] = old.[ctlo]
        AND [ColumnAssigned] = 'C';
  DELETE FROM [.vw_object_column_data]
  WHERE [oldCollectionID] = old.[CollectionID] AND [oldObjectID] = old.[ObjectID] AND [oldctlo] = old.[ctlo]
        AND [ColumnAssigned] = 'D';
  DELETE FROM [.vw_object_column_data]
  WHERE [oldCollectionID] = old.[CollectionID] AND [oldObjectID] = old.[ObjectID] AND [oldctlo] = old.[ctlo]
        AND [ColumnAssigned] = 'E';
  DELETE FROM [.vw_object_column_data]
  WHERE [oldCollectionID] = old.[CollectionID] AND [oldObjectID] = old.[ObjectID] AND [oldctlo] = old.[ctlo]
        AND [ColumnAssigned] = 'F';
  DELETE FROM [.vw_object_column_data]
  WHERE [oldCollectionID] = old.[CollectionID] AND [oldObjectID] = old.[ObjectID] AND [oldctlo] = old.[ctlo]
        AND [ColumnAssigned] = 'G';
  DELETE FROM [.vw_object_column_data]
  WHERE [oldCollectionID] = old.[CollectionID] AND [oldObjectID] = old.[ObjectID] AND [oldctlo] = old.[ctlo]
        AND [ColumnAssigned] = 'H';
  DELETE FROM [.vw_object_column_data]
  WHERE [oldCollectionID] = old.[CollectionID] AND [oldObjectID] = old.[ObjectID] AND [oldctlo] = old.[ctlo]
        AND [ColumnAssigned] = 'I';
  DELETE FROM [.vw_object_column_data]
  WHERE [oldCollectionID] = old.[CollectionID] AND [oldObjectID] = old.[ObjectID] AND [oldctlo] = old.[ctlo]
        AND [ColumnAssigned] = 'J';

END;

------------------------------------------------------------------------------------------
-- .vw_object_column_data
------------------------------------------------------------------------------------------
CREATE VIEW IF NOT EXISTS [.vw_object_column_data]
AS
  SELECT
    NULL AS [oldCollectionID],
    NULL AS [oldObjectID],
    NULL AS [oldctlo],
    NULL AS [oldValue],
    NULL AS [CollectionID],
    NULL AS [ObjectID],
    NULL AS [ctlo],
    NULL AS [ColumnAssigned],
    NULL AS [Value];

CREATE TRIGGER IF NOT EXISTS [trigDummyObjectColumnDataInsert]
INSTEAD OF INSERT ON [.vw_object_column_data]
FOR EACH ROW
BEGIN
  INSERT INTO [.full_text_data] ([PropertyID], [CollectionID], [ObjectID], [PropertyIndex], [Value])
    SELECT
      printf('#%s#', new.[ColumnAssigned]),
      printf('#%s#', new.[CollectionID]),
      printf('#%s#', new.[ObjectID]),
      '#0#',
      new.[Value]
    WHERE new.[ColumnAssigned] IS NOT NULL AND new.ctlo & (1 << (17 + unicode(new.[ColumnAssigned]) - unicode('A'))) AND
          typeof(new.[Value]) = 'text';
END;

CREATE TRIGGER IF NOT EXISTS [trigDummyObjectColumnDataUpdate]
INSTEAD OF UPDATE ON [.vw_object_column_data]
FOR EACH ROW
BEGIN
  -- Process full text data based on ctlo
  DELETE FROM [.full_text_data]
  WHERE
    new.[ColumnAssigned] IS NOT NULL AND
    new.oldctlo & (1 << (17 + unicode(new.[ColumnAssigned]) - unicode('A'))) AND typeof(new.[oldValue]) = 'text'
    AND [PropertyID] MATCH printf('#%s#', new.[ColumnAssigned])
    AND [CollectionID] MATCH printf('#%s#', new.[oldCollectionID])
    AND [ObjectID] MATCH printf('#%s#', new.[oldObjectID])
    AND [PropertyIndex] MATCH '#0#';

  INSERT INTO [.full_text_data] ([PropertyID], [CollectionID], [ObjectID], [PropertyIndex], [Value])
    SELECT
      printf('#%s#', new.[ColumnAssigned]),
      printf('#%s#', new.[CollectionID]),
      printf('#%s#', new.[ObjectID]),
      '#0#',
      new.[Value]
    WHERE new.[ColumnAssigned] IS NOT NULL AND new.ctlo & (1 << (17 + unicode(new.[ColumnAssigned]) - unicode('A'))) AND
          typeof(new.[Value]) = 'text';
END;

CREATE TRIGGER IF NOT EXISTS [trigDummyObjectColumnDataDelete]
INSTEAD OF DELETE ON [.vw_object_column_data]
FOR EACH ROW
BEGIN
  -- Process full text data based on ctlo
  DELETE FROM [.full_text_data]
  WHERE
    old.[ColumnAssigned] IS NOT NULL AND
    old.oldctlo & (1 << (17 + unicode(old.[ColumnAssigned]) - unicode('A'))) AND typeof(old.[oldValue]) = 'text'
    AND [PropertyID] MATCH printf('#%s#', old.[ColumnAssigned])
    AND [CollectionID] MATCH printf('#%s#', old.[oldCollectionID])
    AND [ObjectID] MATCH printf('#%s#', old.[oldObjectID])
    AND [PropertyIndex] MATCH '#0#';
END;


------------------------------------------------------------------------------------------
-- .range_data
------------------------------------------------------------------------------------------
CREATE VIRTUAL TABLE IF NOT EXISTS [.range_data] USING rtree (
  [id],
  [CollectionID0], [CollectionID1],
  [ObjectID0], [ObjectID1],
  [PropertyID0], [PropertyID1],
  [PropertyIndex0], [PropertyIndex1],
  [StartValue], [EndValue]
);

------------------------------------------------------------------------------------------
-- Values
-- This table stores EAV individual values in a canonical form - one DB row per value
-- Also, this table keeps list of object-to-object references. Direct reference is ObjectID.PropertyID -> Value
-- where Value is ID of referenced object.
-- Reversed reference is from Value -> ObjectID.PropertyID
------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS [.ref-values] (
  [ObjectID]   INTEGER NOT NULL,
  [PropertyID] INTEGER NOT NULL,
  [PropIndex]  INTEGER NOT NULL DEFAULT 0,
  [Value]              NOT NULL,
  [CollectionID]    INTEGER NOT NULL,

  /*
  ctlv is used for index control. Possible values:
      0 - Index
      1-3 - reference
          2(3 as bit 0 is set) - regular ref
          4(5) - ref: A -> B. When A deleted, delete B
          6(7) - when B deleted, delete A
          8(9) - when A or B deleted, delete counterpart
          10(11) - cannot delete A until this reference exists
          12(13) - cannot delete B until this reference exists
          14(15) - cannot delete A nor B until this reference exist

      16 - full text data
      32 - range data
      64 - DON'T track changes
  */
  [ctlv]       INTEGER,
  CONSTRAINT [] PRIMARY KEY ([ObjectID], [CollectionID], [PropertyID], [PropIndex])
) WITHOUT ROWID;

CREATE INDEX IF NOT EXISTS [idxClassReversedRefs] ON [.ref-values] ([Value], [PropertyID]) WHERE [ctlv] & 14;

CREATE INDEX IF NOT EXISTS [idxValuesByClassPropValue] ON [.ref-values] ([PropertyID], [CollectionID], [Value]) WHERE ([ctlv] & 1);

CREATE TRIGGER IF NOT EXISTS [trigValuesAfterInsert]
AFTER INSERT
ON [.ref-values]
FOR EACH ROW
BEGIN
  INSERT INTO [.change_log] ([KEY], [Value])
    SELECT
      printf('@%s.%s/%s[%s]#%s',
             new.[CollectionID], new.[ObjectID], new.[PropertyID], new.PropIndex,
             new.ctlv),
      new.[Value]
    WHERE (new.[ctlv] & 64) <> 64;

  INSERT INTO [.full_text_data] ([PropertyID], [CollectionID], [ObjectID], [PropertyIndex], [Value])
    SELECT
      printf('#%s#', new.[PropertyID]),
      printf('#%s#', new.[CollectionID]),
      printf('#%s#', new.[ObjectID]),
      printf('#%s#', new.[PropIndex]),
      new.[Value]
    WHERE new.ctlv & 16 AND typeof(new.[Value]) = 'text';

  -- process range data
END;

CREATE TRIGGER IF NOT EXISTS [trigValuesAfterUpdate]
AFTER UPDATE
ON [.ref-values]
FOR EACH ROW
BEGIN
  INSERT INTO [.change_log] ([OldKey], [OldValue], [KEY], [Value])
    SELECT
      [OldKey],
      [OldValue],
      [KEY],
      [Value]
    FROM
      (SELECT
         /* Each piece of old key is formatted independently so that for cases when old and new value is the same,
         result will be null and will be placed to OldKey as empty string */
         printf('%s%s%s%s%s',
                '@' || CAST(nullif(old.[CollectionID], new.[CollectionID]) AS TEXT),
                '.' || CAST(nullif(old.[ObjectID], new.[ObjectID]) AS TEXT),
                '/' || CAST(nullif(old.[PropertyID], new.[PropertyID]) AS TEXT),
                '[' || CAST(nullif(old.[PropIndex], new.[PropIndex]) AS TEXT) || ']',
                '#' || CAST(nullif(old.[ctlv], new.[ctlv]) AS TEXT)
         )                                                         AS [OldKey],
         old.[Value]                                               AS [OldValue],
         printf('@%s.%s/%s[%s]%s',
                new.[CollectionID], new.[ObjectID], new.[PropertyID], new.PropIndex,
                '#' || CAST(nullif(new.ctlv, old.[ctlv]) AS TEXT)) AS [KEY],
         new.[Value]                                               AS [Value])
    WHERE (new.[ctlv] & 64) <> 64 AND ([OldValue] <> [Value] OR (nullif([OldKey], [KEY])) IS NOT NULL);

  -- Process full text data based on ctlv
  DELETE FROM [.full_text_data]
  WHERE
    old.ctlv & 16 AND typeof(old.[Value]) = 'text'
    AND [PropertyID] MATCH printf('#%s#', old.[PropertyID])
    AND [CollectionID] MATCH printf('#%s#', old.[CollectionID])
    AND [ObjectID] MATCH printf('#%s#', old.[ObjectID])
    AND [PropertyIndex] MATCH printf('#%s#', old.[PropIndex]);

  INSERT INTO [.full_text_data] ([PropertyID], [CollectionID], [ObjectID], [PropertyIndex], [Value])
    SELECT
      printf('#%s#', new.[PropertyID]),
      printf('#%s#', new.[CollectionID]),
      printf('#%s#', new.[ObjectID]),
      printf('#%s#', new.[PropIndex]),
      new.[Value]
    WHERE new.ctlv & 16 AND typeof(new.[Value]) = 'text';

  -- Process range data based on ctlv

END;

CREATE TRIGGER IF NOT EXISTS [trigValuesAfterDelete]
AFTER DELETE
ON [.ref-values]
FOR EACH ROW
BEGIN
  INSERT INTO [.change_log] ([OldKey], [OldValue])
    SELECT
      printf('@%s.%s/%s[%s]',
             old.[CollectionID], old.[ObjectID], old.[PropertyID],
             old.PropIndex),
      old.[Value]
    WHERE (old.[ctlv] & 64) <> 64;

  -- Delete weak referenced object in case this Value record was last reference to that object
  DELETE FROM [.objects]
  WHERE old.ctlv IN (3) AND ObjectID = old.Value AND
        (ctlo & 1) = 1 AND (SELECT count(*)
                            FROM [.ref-values]
                            WHERE [Value] = ObjectID AND ctlv IN (3)) = 0;

  -- Process full text data based on ctlv
  DELETE FROM [.full_text_data]
  WHERE
    old.[ctlv] & 16 AND typeof(old.[Value]) = 'text'
    AND [PropertyID] MATCH printf('#%s#', old.[PropertyID])
    AND [CollectionID] MATCH printf('#%s#', old.[CollectionID])
    AND [ObjectID] MATCH printf('#%s#', old.[ObjectID])
    AND [PropertyIndex] MATCH printf('#%s#', old.[PropIndex]);

  -- TODO Process range data based on ctlv
END;

--------------------------------------------------------------------------------------------
-- .ValuesEasy
--------------------------------------------------------------------------------------------
CREATE VIEW IF NOT EXISTS [.ValuesEasy] AS
  SELECT
    NULL AS [NameID],
    NULL AS [HostID],
    NULL AS [ObjectID],
    NULL AS [PropertyName],
    NULL AS [PropertyIndex],
    NULL AS [Value];

CREATE TRIGGER IF NOT EXISTS trigValuesEasy_Insert INSTEAD OF INSERT
ON [.ValuesEasy]
FOR EACH ROW
BEGIN
  INSERT OR REPLACE INTO [.objects] (CollectionID, ObjectID, ctlo, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)
    SELECT
      c.CollectionID,
      (new.HostID << 31) | new.[ObjectID],

      ctlo = c.ctloMask,

      A = (CASE WHEN p.[ColumnAssigned] = 'A'
        THEN new.[Value]
           ELSE A END),

      B = (CASE WHEN p.[ColumnAssigned] = 'B'
        THEN new.[Value]
           ELSE B END),

      C = (CASE WHEN p.[ColumnAssigned] = 'C'
        THEN new.[Value]
           ELSE C END),

      D = (CASE WHEN p.[ColumnAssigned] = 'D'
        THEN new.[Value]
           ELSE D END),

      E = (CASE WHEN p.[ColumnAssigned] = 'E'
        THEN new.[Value]
           ELSE E END),

      F = (CASE WHEN p.[ColumnAssigned] = 'F'
        THEN new.[Value]
           ELSE F END),

      G = (CASE WHEN p.[ColumnAssigned] = 'G'
        THEN new.[Value]
           ELSE G END),

      H = (CASE WHEN p.[ColumnAssigned] = 'H'
        THEN new.[Value]
           ELSE H END),

      I = (CASE WHEN p.[ColumnAssigned] = 'I'
        THEN new.[Value]
           ELSE I END),

      J = (CASE WHEN p.[ColumnAssigned] = 'J'
        THEN new.[Value]
           ELSE J END)

    FROM [.collections] c, [.vw_class_properties] p
    WHERE c.[CollectionID] = p.[CollectionID] AND c.NameID = new.NameID AND p.PropertyName = new.PropertyName
          AND (p.[ctlv] & 14) = 0 AND p.ColumnAssigned IS NOT NULL AND new.PropertyIndex = 0;

  INSERT OR REPLACE INTO [.ref-values] (ObjectID, CollectionID, PropertyID, PropIndex, [Value], ctlv)
    SELECT
      CASE WHEN new.PropertyIndex > 20
        THEN new.[ObjectID] | (1 << 62)
      ELSE new.[ObjectID] END,
      c.CollectionID,
      p.PropertyID,
      new.PropertyIndex,
      new.[Value],
      p.[ctlv]
    FROM [.collections] c, [.vw_class_properties] p
    WHERE c.[CollectionID] = p.[CollectionID] AND c.NameID = new.NameID AND p.PropertyName = new.PropertyName AND
          p.ColumnAssigned IS NULL;
END;

--------------------------------------------------------------------------------------------
-- .values_view - wraps access to .values table by providing separate HostID and ObjectID columns
--------------------------------------------------------------------------------------------
create view if not exists [.ref-values_view] as
select CollectionID, [ObjectID] >> 31 as HostID,
                    ([ObjectID] & 2147483647) as ObjectID, ctlv, PropertyID, PropIndex, [Value]
from [.ref-values];

create trigger if not exists values_view_Insert instead of insert on [.ref-values_view]
for each row
begin
    insert into [.ref-values]
    (
    CollectionID, [ObjectID], ctlv, PropertyID, PropIndex, [Value]
    )
    values (
    new.CollectionID, new.[ObjectID] << 31 | (new.[ObjectID] & 2147483647), new.ctlv,
    new.PropertyID, new.PropIndex, new.[Value]
    );
end;

create trigger if not exists values_view_Update instead of update on [.ref-values_view]
for each row
begin
    update [.ref-values] set
    CollectionID = new.CollectionID,
     [ObjectID] = new.[ObjectID] << 31 | (new.[ObjectID] & 2147483647),
     ctlv = new.ctlv,
    PropertyID = new.PropertyID, PropIndex = new.PropIndex, [Value] = new.[Value]
    where [ObjectID] = old.[ObjectID] << 31 | (old.[ObjectID] & 2147483647)
    and [PropertyID] = old.[PropertyID] and [PropIndex] = old.[PropIndex];
end;

create trigger if not exists values_view_Delete instead of delete on [.ref-values_view]
for each row
begin
    delete from [.ref-values]
   where [ObjectID] = old.[ObjectID] << 31 | (old.[ObjectID] & 2147483647)
       and [PropertyID] = old.[PropertyID] and [PropIndex] = old.[PropIndex];
end;

--------------------------------------------------------------------------------------------
-- .vw_objects - Access to objects data, with handling JSONPath & HostID cases
--------------------------------------------------------------------------------------------
create view if not exists [.vw_objects] as select
[ObjectID],
[SchemaID],
[HostID],
[CollectionID],
[ctlo],
[A],
[B],
[C],
[D],
[E],
[F],
[G],
[H],
[I],
[J],

(WITH RECURSIVE
  obj(h, d) AS (select HostID as h, Data as d UNION ALL SELECT o2.HostID, json_extract(o2.Data, d) from [.objects] o2 WHERE o2.ObjectID = h)
SELECT d FROM obj limit 1) as [Data]

from [.objects];

--------------------------------------------------------------------------------------------
-- .vw_objects_full - Access to full objects data, with handling JSONPath & HostID cases
-- AND shortcut fields
--------------------------------------------------------------------------------------------
create view if not exists [.vw_objects_full] as select
o.[ObjectID],
o.[SchemaID],
o.[HostID],
o.[CollectionID],
o.[ctlo],
[Data] = json_set(o.Data,
case when o.A is null or c.A is null then null else json_extract( s.Data, '$.properties.' || c.A || '.jsonPath') end, o.A,
case when o.B is null or c.B is null then null else json_extract( s.Data, '$.properties.' || c.B || '.jsonPath') end, o.B,
case when o.C is null or c.C is null then null else json_extract( s.Data, '$.properties.' || c.C || '.jsonPath') end, o.C,
case when o.D is null or c.D is null then null else json_extract( s.Data, '$.properties.' || c.D || '.jsonPath') end, o.D,
case when o.E is null or c.E is null then null else json_extract( s.Data, '$.properties.' || c.E || '.jsonPath') end, o.E,
case when o.F is null or c.F is null then null else json_extract( s.Data, '$.properties.' || c.F || '.jsonPath') end, o.F,
case when o.G is null or c.G is null then null else json_extract( s.Data, '$.properties.' || c.G || '.jsonPath') end, o.G,
case when o.H is null or c.H is null then null else json_extract( s.Data, '$.properties.' || c.H || '.jsonPath') end, o.H,
case when o.I is null or c.I is null then null else json_extract( s.Data, '$.properties.' || c.I || '.jsonPath') end, o.I,
case when o.J is null or c.J is null then null else json_extract( s.Data, '$.properties.' || c.J || '.jsonPath') end, o.J
)
from [.vw_objects] o join [.schemas] s on o.SchemaID = s.SchemaID
join [.collections] c on o.CollectionID = c.CollectionID;

--------------------------------------------------------------------------------------------
-- .vw_values - internal universal view to select actual property values
--
--------------------------------------------------------------------------------------------
create view if not exists [.vw_values] as with recursive prop_val(v) as (select
coalesce(
json_extract(o.Data, json_extract(s.Data, '$.properties.1.map.jsonPath')),
 case
     when json_extract(s.Data, '$.properties.1.map.ref') is not null then
        (select from [.objects] o2, [.ref-values] rv2 where rv2.ObjectID = o2.ObjectID
        and rv2.PropertyID = json_extract(s.Data, '$.properties.1.ref.linkPropID'))
     else null
 end
 )

 from [.objects] o left outer [.schemas] s on o.SchemaID = s.SchemaID
from [.objects] o join [.schemas] s on o.SchemaID = s.SchemaID) select * from prop_val;
--
--CREATE TABLE json_tree(
--    key ANY,             -- key for current element relative to its parent
--    value ANY,           -- value for the current element
--    type TEXT,           -- 'object','array','string','integer', etc.
--    atom ANY,            -- value for primitive types, null for array & object
--    id INTEGER           -- integer ID for this element
--    parent INTEGER,      -- integer ID for the parent of this element
--    fullkey TEXT,        -- full path describing the current element
--    path TEXT,           -- path to the container of the current row
--    json JSON HIDDEN,    -- 1st input parameter: the raw JSON
--    root TEXT HIDDEN     -- 2nd input parameter: the PATH at which to start
--);

