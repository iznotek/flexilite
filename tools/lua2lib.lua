---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by slanska.
--- DateTime: 2018-06-12 6:27 PM
---

--[[
Command line utility to compile list of .lua files to .obj format (using luajit -b)
and then bundle all files to a static library to be linked with C/C++ project
]]

if not jit then
    error 'This No jit found. Ensure that script is run by LuaJIT, not regular Lua'
end

local os = require 'os'
local path = require 'pl.path'
local lapp = require 'pl.lapp'
local stringx = require 'pl.stringx'
local pretty = require 'pl.pretty'

-- set lua paths
local paths = {
    '../lib/debugger-lua/?.lua',
    '../lib/md5.lua/?.lua',
    './lib/md5.lua/?.lua',
    '../lib/lua-ansicolors/?.lua',
    './lib/lua-ansicolors/?.lua',
    '../?.lua',
}

for _, pp in ipairs(paths) do
    package.path = path.abspath(path.relpath(pp)) .. ';' .. package.path
end

local md5 = require 'md5'
local ansicolors = require 'ansicolors'

local cli_args = lapp [[
Compile lua-to-static-library
<filelist> (string)  Path to file list .lua module
    -n, --name (string default 'luaModules.a')  Name of target library
    -o, --output (string default 'obj_lua')  Output path
]]

---@param cmd string
local function os_execute(cmd)
    local result, _, code = os.execute(cmd)
    if result == nil then
        error(string.format('Error executing command [%s]: code %s', cmd, code))
    end
end

local file_list = path.abspath(path.relpath(cli_args.filelist))

--local files = require(cli_args.filelist)
local files = loadfile(file_list)()

local libName = path.splitext(path.basename(cli_args.name))

local out_path = path.join(path.abspath(cli_args.output), libName)

if not path.exists(out_path) then
    if jit.os == 'Windows' then
        os.execute(string.format('mkdir "%s"', out_path))
    else
        os.execute(string.format('mkdir -p "%s"', out_path))
    end
end

local cfg = {}

-- Load previous stats (if exists)
local cfgFilePath = path.join(out_path, '.lua2lib')
local cfgFile = io.open(cfgFilePath, 'r')
if cfgFile ~= nil then
    local cfgStr = cfgFile:read("*all")
    cfg = pretty.read(cfgStr)
    cfgFile:close()
end

---@param filePath string
---@return string @comment calculated MD5 checksum of contents of file by filePath
local function calcMD5(filePath)
    local f = io.open(filePath, 'r')
    if f ~= nil then
        local content = f:read('*all')
        local result = md5.sumhexa(content)
        f:close()
        return result
    end

    return nil
end

local md5changed = false

-- Process file list
for module_name, file_name in pairs(files) do
    -- Compile .lua file
    local nn = ''
    if type(file_name) ~= 'number'
            and type(module_name) == 'string' and module_name ~= '' then
        nn = 'n ' .. module_name
    else
        file_name = module_name
    end

    local cmd

    -- Current directory is expected to be flexilite
    local file_path = path.abspath(path.relpath(file_name))
    local _, ext = path.splitext(file_path)

    local newMd5 = calcMD5(file_path)
    local processingNeeded = false

    -- Analyze if file has changed since last processing
    local prevMd5 = cfg[module_name]
    if prevMd5 == nil or prevMd5 ~= newMd5 then
        processingNeeded = true
        md5changed = true
    end

    cfg[module_name] = newMd5

    if processingNeeded then
        if ext ~= '.lua' then
            -- Non Lua files are treated as string resources (e.g. SQL files)
            -- Read file content
            local in_file = io.open(file_path, 'r')
            local res_str = in_file:read("*all")
            in_file:close()

            -- Encode it as string
            local code = string.format('return %s', stringx.quote_string(res_str))

            -- Save as temp file
            local file_path = os.tmpname()
            local tmp_file = io.open(file_path, 'w')

            tmp_file:write(code)
            tmp_file:close()

            -- Compile to .o
            local o_file = path.abspath(path.join(out_path, path.relpath(
                    string.gsub(string.gsub(file_name, '/', '.'),
                            '%.%.%.', '') .. '.o')))

            cmd = string.format('luajit -b%s "%s" "%s"',
                    nn, file_path, o_file)

            print(ansicolors(string.format('%%{magenta}%s: compiling %s%%{reset}', libName, file_name)))

            os_execute(cmd)

            --Delete temp file
            os.remove(file_path)
        else
            -- Compile to .o
            local o_file = path.abspath(path.join(out_path, path.relpath(
                    string.gsub(string.gsub(file_name, '/', '.'),
                            '%.%.%.', '') .. '.o')))
            cmd = string.format('luajit -bg%s  "%s" "%s"',
                    nn, file_path, o_file)

            print(ansicolors(string.format('%%{yellow}%s: compiling %s%%{reset}', libName, file_name)))

            os_execute(cmd)
        end
    else
        print(ansicolors(string.format('%%{cyan}Skipping unchanged %s%%{reset}', module_name)))
    end
end

-- Save updated config
if md5changed then
    cfgFile = io.open(cfgFilePath, 'w+')
    if cfgFile ~= nil then
        local cfgStr = pretty.write(cfg)
        cfg = cfgFile:write(cfgStr)
        cfgFile:close()
    end
end

-- Bundle library into single archive
if jit.os == 'Windows' then
    -- Use Visual Studio LIB tool to build static ibrary
    local cmd = string.format('lib  -nologo -out:%s %s/*.o', path.join(out_path, cli_args.name), out_path)
    os_execute(cmd)
else
    -- *NIX - use AR for building static library
    local cmd = string.format('ar rcus %s %s/*.o', path.join(out_path, cli_args.name), out_path)
    os_execute(cmd)
end

